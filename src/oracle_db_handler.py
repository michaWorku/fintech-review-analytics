import pandas as pd
import oracledb

class OracleDBHandler:
    def __init__(self, user, password, dsn):
        """
        Initialize Oracle DB connection
        """
        self.user = user
        self.password = password
        self.dsn = dsn
        self.conn = None
        self.cursor = None

    def connect(self):
        """Connect to Oracle"""
        try:
            self.conn = oracledb.connect(user=self.user, password=self.password, dsn=self.dsn)
            self.cursor = self.conn.cursor()
            print("‚úÖ Connected to Oracle DB.")
        except Exception as e:
            print(f"‚ùå Connection error: {e}")
            raise

    def close(self):
        """Close connection"""
        if self.cursor: self.cursor.close()
        if self.conn: self.conn.close()
        print("üîí Connection closed.")

    def create_schema(self):
        """Create tables for banks and reviews"""
        try:
            self.cursor.execute("""
                CREATE TABLE banks (
                    bank_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    name VARCHAR2(100) UNIQUE NOT NULL
                )
            """)
            self.cursor.execute("""
                CREATE TABLE reviews (
                    review_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    bank_id NUMBER REFERENCES banks(bank_id),
                    review_text CLOB,
                    cleaned_review CLOB,
                    rating NUMBER,
                    sentiment_label VARCHAR2(50),
                    sentiment_score FLOAT,
                    theme VARCHAR2(100),
                    review_date DATE,
                    source VARCHAR2(50)
                )
            """)
            self.conn.commit()
            print("‚úÖ Schema created.")
        except Exception as e:
            print(f"‚ö†Ô∏è Schema creation failed: {e}")
            self.conn.rollback()

    def insert_banks(self, banks):
        """Insert bank names and return a bank_id map"""
        bank_map = {}
        for bank in banks:
            try:
                self.cursor.execute(
                    "INSERT INTO banks (name) VALUES (:1) RETURNING bank_id INTO :2",
                    [bank, self.cursor.var(int)]
                )
                bank_id = self.cursor.fetchone()[0]
                bank_map[bank] = bank_id
            except oracledb.IntegrityError:
                self.cursor.execute("SELECT bank_id FROM banks WHERE name = :name", {'name': bank})
                bank_map[bank] = self.cursor.fetchone()[0]
        self.conn.commit()
        return bank_map

    def insert_reviews(self, df: pd.DataFrame):
        """Insert cleaned review data"""
        bank_map = self.insert_banks(df['bank'].unique())

        for _, row in df.iterrows():
            try:
                self.cursor.execute("""
                    INSERT INTO reviews (
                        bank_id, review_text, cleaned_review, rating,
                        sentiment_label, sentiment_score, theme, review_date, source
                    )
                    VALUES (
                        :bank_id, :review, :cleaned_review, :rating,
                        :sentiment_label, :sentiment_score, :theme, TO_DATE(:review_date, 'YYYY-MM-DD'), :source
                    )
                """, {
                    'bank_id': bank_map[row['bank']],
                    'review': row['review'],
                    'cleaned_review': row['cleaned_review'],
                    'rating': int(row['rating']),
                    'sentiment_label': row['transformer_sentiment'],
                    'sentiment_score': float(row['transformer_score']),
                    'theme': row.get('theme', None),
                    'review_date': row['date'],
                    'source': row['source']
                })
            except Exception as e:
                print(f"‚ùå Failed to insert row: {e}")
        self.conn.commit()
        print(f"üì• Inserted {len(df)} reviews.")

    def fetch_reviews(self, limit=10):
        """Fetch limited number of reviews"""
        try:
            self.cursor.execute("""
                SELECT r.review_id, b.name as bank_name, r.review_text, r.rating, r.sentiment_label, r.theme
                FROM reviews r
                JOIN banks b ON r.bank_id = b.bank_id
                FETCH FIRST :limit ROWS ONLY
            """, {'limit': limit})
            results = self.cursor.fetchall()
            for row in results:
                print(row)
            return results
        except Exception as e:
            print(f"‚ùå Error fetching reviews: {e}")

    def update_theme_by_id(self, review_id, new_theme):
        """Update the theme of a review by ID"""
        try:
            self.cursor.execute("""
                UPDATE reviews SET theme = :theme WHERE review_id = :id
            """, {'theme': new_theme, 'id': review_id})
            self.conn.commit()
            print(f"‚úÖ Updated review {review_id} theme to '{new_theme}'")
        except Exception as e:
            print(f"‚ùå Failed to update: {e}")

    def delete_review_by_id(self, review_id):
        """Delete a review by ID"""
        try:
            self.cursor.execute("DELETE FROM reviews WHERE review_id = :id", {'id': review_id})
            self.conn.commit()
            print(f"üóëÔ∏è Deleted review with ID {review_id}")
        except Exception as e:
            print(f"‚ùå Failed to delete: {e}")

    def update_sentiment_by_review_id(self, review_id, sentiment_label, sentiment_score):
        """
        Update sentiment fields of a specific review by ID
        """
        try:
            self.cursor.execute("""
                UPDATE reviews
                SET sentiment_label = :label,
                    sentiment_score = :score
                WHERE review_id = :id
            """, {'label': sentiment_label, 'score': sentiment_score, 'id': review_id})
            self.conn.commit()
            print(f"‚úÖ Updated sentiment for review ID {review_id}")
        except Exception as e:
            print(f"‚ùå Failed to update sentiment: {e}")

    def update_sentiment_by_bank_name(self, bank_name, sentiment_label, sentiment_score):
        """
        Update sentiment for all reviews from a given bank name
        """
        try:
            self.cursor.execute("""
                UPDATE reviews
                SET sentiment_label = :label,
                    sentiment_score = :score
                WHERE bank_id = (
                    SELECT bank_id FROM banks WHERE name = :bank
                )
            """, {'label': sentiment_label, 'score': sentiment_score, 'bank': bank_name})
            self.conn.commit()
            print(f"‚úÖ Updated sentiment for all reviews of {bank_name}")
        except Exception as e:
            print(f"‚ùå Failed to update sentiments for bank: {e}")

    def get_reviews_by_bank(self, bank_name, limit=10):
        """
        Retrieve reviews for a given bank
        """
        try:
            self.cursor.execute("""
                SELECT r.review_id, r.review_text, r.rating, r.sentiment_label, r.theme, r.review_date
                FROM reviews r
                JOIN banks b ON r.bank_id = b.bank_id
                WHERE b.name = :name
                FETCH FIRST :limit ROWS ONLY
            """, {'name': bank_name, 'limit': limit})
            rows = self.cursor.fetchall()
            print(f"\nüìÑ Top {limit} reviews for {bank_name}:")
            for row in rows:
                print(row)
            return rows
        except Exception as e:
            print(f"‚ùå Failed to retrieve reviews: {e}")
